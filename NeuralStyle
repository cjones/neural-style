#!/usr/bin/env python

import traceback
import functools
import warnings
import select
import signal
import errno
import sys
import abc
import os
import re

from PyQt5.Qt import *

script = os.path.abspath(__file__)
prefix, prog = os.path.split(script)
sys.path.insert(0, os.path.join(prefix, 'lib', 'python'))

from mainwindow_ui import Ui_MainWindow
from menubar_ui import Ui_MenuBar


class BaseType(abc.ABCMeta):

    def __str__(cls):
        return cls.__name__

    def __repr__(cls):
        return cls.__name__


class Base:
    __metaclass__ = BaseType


class OverrideChecker(Base):

    def __init__(self):
        self.funcs = []

    def __call__(self, cls):
        self.check(cls)
        return cls

    def check(self, cls):
        if issubclass(cls, type):
            args = (cls,)
        else:
            args = ()
        this = set()
        that = set()
        for sub in cls.mro(*args):
            if sub is cls:
                dst = this
            else:
                dst = that
            dst.update(vars(sub))
        for name in this & that:
            if not (name.startswith('_abc_') or name.startswith('__')):
                meth = getattr(cls, name)
                func = getattr(meth, 'im_func', meth)
                if func not in self.funcs:
                    warnings.warn('undeclared override: {}.{}'.format(cls.__name__, name))

    def override(self, func):
        self.funcs.append(func)
        return func


checked = OverrideChecker()
override = checked.override


@checked
class EnumType(type(Base)):
    pass


@checked
class Enum(Base):
    __metaclass__ = EnumType


@checked
class ExitCode(Enum):
    OK = 0
    ERROR = 1
    USAGE = 2
    IPYTHON = 32
    RESTART = 64
    SIGNAL = 128


@checked
class Container(Base):

    def __init__(self, *args, **kwargs):
        vars(self).update(*args, **kwargs)


@checked
class QBaseType(type(QObject), type(Base)):
    pass


@checked
class QBase(QObject, Base):
    __metaclass__ = QBaseType


@checked
class UIBase(QBase):

    def __init__(self, manager, *args, **kwargs):
        super(UIBase, self).__init__(*args, **kwargs)
        self.manager = manager
        self.setupUi(self)

    @abc.abstractmethod
    def setupUi(self, *args, **kwargs):
        raise NotImplementedError

    def get_app(self):
        return self.manager.app

    app = property(get_app)


@checked
class MenuBar(Ui_MenuBar, QMenuBar, UIBase):

    def __init__(self, *args, **kwargs):
        self.action_groups = {}
        super(MenuBar, self).__init__(*args, **kwargs)

    def iter_menu_actions(self):
        for action in self.findChildren(QAction):
            if action.menu() is None and not action.isSeparator():
                yield action

    def get_menu_actions(self):
        return list(self.iter_menu_actions())

    menu_actions = property(get_menu_actions)

    @override
    def setupUi(self, *args, **kwargs):
        super(MenuBar, self).setupUi(*args, **kwargs)
        for action in self.menu_actions:
            shortcut_name = action.property('standard_shortcut')
            if shortcut_name:
                shortcut = getattr(QKeySequence, shortcut_name, None)
                if shortcut is not None:
                    key = QKeySequence(shortcut)
                    action.setShortcut(key)
            group_name = action.property('action_group')
            if group_name:
                group = self.action_groups.get(group_name)
                if group is None:
                    group = self.action_groups[group_name] = QActionGroup(action.parent())
                    group.setExclusive(True)
                group.addAction(action)
            object_name = action.objectName()
            action_name = re.sub(r'(^action_?|_?action$)', '', object_name, flags=re.IGNORECASE)
            handler_name = 'on_{}_triggered'.format(action_name)
            handler = getattr(self.manager, handler_name, None)
            if handler is None:
                print >> sys.stderr, '    @pyqtSlot()'
                print >> sys.stderr, '    def {}(self):'.format(handler_name)
                print >> sys.stderr, '        raise NotImplementedError({!r})'.format(action_name)
                print >> sys.stderr
            else:
                action.triggered.connect(handler)


@checked
class MainWindow(Ui_MainWindow, QMainWindow, UIBase):
    pass


@checked
class WindowManager(QBase):
    menubar_class = MenuBar
    mainwindow_class = MainWindow

    def __init__(self, app, *args, **kwargs):
        super(WindowManager, self).__init__(*args, **kwargs)
        self.app = app
        self.menubar = self.menubar_class(self, None)
        self.windows = []
        self.new_window()
        self.setup_app()

    def setup_app(self):
        self.app.setQuitOnLastWindowClosed(False)

    def new_window(self, parent=None, show=True):
        window = self.mainwindow_class(self)
        if show:
            window.show()
        self.windows.append(window)
        return window

    @pyqtSlot()
    def on_about_triggered(self):
        raise NotImplementedError(u'about')

    @pyqtSlot()
    def on_prefs_triggered(self):
        raise NotImplementedError(u'prefs')

    @pyqtSlot()
    def on_quit_triggered(self):
        self.app.quit()

    @pyqtSlot()
    def on_new_window_triggered(self):
        raise NotImplementedError(u'new_window')

    @pyqtSlot()
    def on_close_window_triggered(self):
        raise NotImplementedError(u'close_window')

    @pyqtSlot()
    def on_undo_triggered(self):
        raise NotImplementedError(u'undo')

    @pyqtSlot()
    def on_redo_triggered(self):
        raise NotImplementedError(u'redo')

    @pyqtSlot()
    def on_cut_triggered(self):
        raise NotImplementedError(u'cut')

    @pyqtSlot()
    def on_copy_triggered(self):
        raise NotImplementedError(u'copy')

    @pyqtSlot()
    def on_paste_triggered(self):
        raise NotImplementedError(u'paste')

    @pyqtSlot()
    def on_delete_triggered(self):
        raise NotImplementedError(u'delete')

    @pyqtSlot()
    def on_select_all_triggered(self):
        raise NotImplementedError(u'select_all')

    @pyqtSlot()
    def on_select_none_triggered(self):
        raise NotImplementedError(u'select_none')

    @pyqtSlot()
    def on_enter_full_screen_triggered(self):
        raise NotImplementedError(u'enter_full_screen')

    @pyqtSlot()
    def on_minimize_window_triggered(self):
        raise NotImplementedError(u'minimize_window')

    @pyqtSlot()
    def on_maximize_window_triggered(self):
        raise NotImplementedError(u'maximize_window')

    @pyqtSlot()
    def on_bring_all_windows_to_front_triggered(self):
        raise NotImplementedError(u'bring_all_windows_to_front')

    @pyqtSlot()
    def on_help_triggered(self):
        raise NotImplementedError(u'help')

    @pyqtSlot()
    def on_run_ipython_triggered(self):
        raise NotImplementedError(u'run_ipython')


@checked
class Application(QApplication, QBase):
    unset = object()
    appkey = 'CFBundleName'
    defaults = {
            'wake_interval': (None, 200),
            'signal_timeout': (unset, None),
            'handle_signals': (None, [signal.SIGHUP, signal.SIGINT, signal.SIGTERM, signal.SIGINFO]),
            'block_size': (None, 4096),
            'appname': (None, 'Neural Style'),
            }

    def __init__(self, *args, **kwargs):
        opts = {}
        for key, (unset, default) in self.defaults.iteritems():
            val = kwargs.pop(key, unset)
            if val is unset:
                val = default
            opts[key] = val
        super(Application, self).__init__(*args, **kwargs)
        self.setApplicationName(opts.pop('appname'))
        vars(self).update(opts)

    def write_socket(self, fd, data, **kwargs):
        return self.do_socket_io(write={fd: data}, **kwargs)

    def read_socket(self, fd, size, **kwargs):
        return self.do_socket_io(read={fd: size}, **kwargs)

    def do_socket_io(self, read=None, write=None, timeout=unset, bsize=None):
        rbufs = {}
        if read is not None:
            for fd, size in read.iteritems():
                rbufs[fd] = {'size': size, 'buf': []}
        wbufs = {}
        if write is not None:
            for fd, buf in write.iteritems():
                wbufs[fd] = {'size': 0, 'buf': [buf]}
        if timeout is self.unset:
            timeout = self.signal_timeout
        if bsize is None:
            bsize = self.block_size
        bufsize = lambda b: sum(map(len, b))
        while True:
            try:
                rfds, wfds = set(), set()
                for fd in rbufs:
                    if rbufs[fd]['size'] > 0:
                        rfds.add(fd)
                for fd in wbufs:
                    if bufsize(wbufs[fd]['buf']) > 0:
                        wfds.add(fd)
                efds = rfds | wfds
                if not efds:
                    break
                r, w, e = select.select(rfds, wfds, efds, timeout)
                if e or not (r or w):
                    break
                for fd in r:
                    block = os.read(fd, min([bsize, rbufs[fd]['size']]))
                    read = len(block)
                    if read > 0:
                        rbufs[fd]['buf'].append(block)
                        rbufs[fd]['size'] -= read
                    else:
                        rbufs.pop(fd)
                for fd in w:
                    data = ''.join(wbufs[fd]['buf'])
                    block, wbufs[fd]['buf'][:] = data[:bsize], [data[bsize:]]
                    wrote = os.write(fd, block)
                    if wrote > 0:
                        wbufs[fd]['buf'].insert(0, block[wrote:])
                        wbufs[fd]['size'] += wrote
                    else:
                        wbufs.pop(fd)

            except (select.error, OSError, IOError), exc:
                code = exc.args[0] if exc.args else -1
                if code == errno.EIO:
                    break
                if code not in {errno.EINTR, errno.AGAIN}:
                    raise

        if rbufs:
            rbufs = {fd: ''.join(rbufs[fd]['buf']) for fd in rbufs}
            if len(rbufs) == 1:
                rbufs = rbufs[next(iter(rbufs))]
        else:
            rbufs = None
        if wbufs:
            wbufs = {fd: wbufs[fd]['size'] for fd in wbufs}
            if len(wbufs) == 1:
                wbufs = wbufs[next(iter(wbufs))]
        else:
            wbufs = None
        return ((None if wbufs is None else wbufs) if rbufs is None
                else (rbufs if wbufs is None else (rbufs, wbufs)))

    def handle_signal(self, sig):
        if sig == signal.SIGHUP:
            ret = ExitCode.RESTART
        elif sig == signal.SIGINFO:
            ret = ExitCode.IPYTHON
        else:
            ret = ExitCode.SIGNAL | sig
        self.exit(ret)

    def run(self, *args, **kwargs):
        try:
            return self.exec_(*args, **kwargs)
        except SystemExit, exc:
            return exc.code
        except KeyboardInterrupt:
            return ExitCode.SIGNAL | signal.SIGINT
        except:
            traceback.print_exc()
            return ExitCode.ERROR

    def run_ipython(self):
        from IPython.Shell import IPShellEmbed

    def loop(self, *args, **kwargs):
        running = True
        ret = ExitCode.OK
        ipython = False
        while running:
            if ipython:
                ipython = False
                self.run_ipython()
            ret = ret | self.run(*args, **kwargs)
            if ret & ExitCode.IPYTHON:
                ipython = True
                ret = ret & ~ExitCode.IPYTHON | ExitCode.RESTART
            if ret & ExitCode.RESTART:
                ret = ret & ~ExitCode.RESTART
            else:
                running = False
        return ret

    @override
    def exec_(self, *args, **kwargs):
        timer_id = self.startTimer(self.wake_interval)
        try:
            r, w = os.pipe()
            try:
                notifier = QSocketNotifier(r, QSocketNotifier.Read)
                try:
                    notifier.setEnabled(False)

                    @pyqtSlot()
                    def handle_socket_event():
                        enabled = notifier.isEnabled()
                        try:
                            notifier.setEnabled(False)
                            for c in self.read_socket(r, 1):
                                if c is not None:
                                    self.handle_signal(ord(c))
                        finally:
                            notifier.setEnabled(enabled)

                    notifier.activated.connect(handle_socket_event)
                    notifier.setEnabled(True)

                    def handle_posix_signal(sig, frame):
                        handler = signal.getsignal(sig)
                        try:
                            signal.signal(sig, signal.SIG_IGN)
                            self.write_socket(w, chr(sig % 256))
                        finally:
                            signal.signal(sig, handler)

                    saved = {}
                    try:
                        for sig in self.handle_signals:
                            saved[sig] = signal.getsignal(sig)
                            signal.signal(sig, handle_posix_signal)
                        return super(Application, self).exec_(*args, **kwargs)
                    finally:
                        for sig, handler in saved.iteritems():
                            signal.signal(sig, handler)
                finally:
                    notifier.setEnabled(False)
                    notifier.deleteLater()
            finally:
                for fd in r, w:
                    os.close(fd)
        finally:
            self.killTimer(timer_id)

    @override
    def event(self, *args, **kwargs):
        return super(Application, self).event(*args, **kwargs)

    def set_osx_appname_pyobjc(self, appname):
        from Foundation import NSBundle
        bundle = NSBundle.mainBundle()
        info = bundle.infoDictionary()
        if appname is not None:
            info[self.appkey] = appname
        return info[self.appkey]

    def init_ctypes_objc(self):
        import ctypes.util
        objc = ctypes.CDLL(ctypes.util.find_library('objc'))
        objc.objc_getClass.argtypes = objc.sel_registerName.argtypes = [ctypes.c_char_p]
        objc.objc_getClass.restype = objc.sel_registerName.restype = objc.objc_msgSend.restype = ctypes.c_void_p
        isstr, isuni = lambda t: isinstance(t, basestring), lambda s: isinstance(s, unicode)

        def msg(cls, sel, *args):
            x = (objc.objc_getClass(cls) if isstr(cls) else cls,
                    objc.sel_registerName(sel) if isstr(sel) else sel) + args
            objc.objc_msgSend.argtypes = [ctypes.c_char_p if isstr(a) else ctypes.c_void_p for a in x]
            return objc.objc_msgSend(*x)

        def str2ns(s):
            return msg('NSString', 'stringWithUTF8String:', s.encode('utf-8') if isuni(s) else s)

        def ns2str(o):
            s = ctypes.string_at(msg(o, 'UTF8String'))
            return s if isuni(s) else s.decode('utf-8')

        return Container(locals())

    def set_osx_appname_ctypes(self, appname):
        objc = self.init_ctypes_objc()
        bundle = objc.msg('NSBundle', 'mainBundle')
        info = objc.msg(bundle, 'infoDictionary')
        key = objc.str2ns(self.appkey)
        if appname is not None:
            objc.msg(info, 'setValue:forKey:', objc.str2ns(appname), key)
        return objc.ns2str(objc.msg(info, 'valueForKey:', key))

    def set_osx_appname(self, appname):
        for func in self.set_osx_appname_pyobjc, self.set_osx_appname_ctypes:
            try:
                func(appname)
            except (SystemExit, KeyboardInterrupt):
                raise
            except:
                pass
            else:
                return True
        return False

    @override
    def setApplicationName(self, *args, **kwargs):
        super(Application, self).setApplicationName(*args, **kwargs)
        appname = self.applicationName()
        self.setApplicationDisplayName(appname)
        self.setObjectName(appname)
        if sys.platform == 'darwin':
            self.set_osx_appname(appname)


def main(argv=None):
    app = Application(sys.argv)
    manager = WindowManager(app)
    manager.menubar.quit_action.setEnabled(True)
    return app.loop()

if __name__ == '__main__':
    sys.exit(main())
